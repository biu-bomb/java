# Keep-Alive

## HTTP

### 功能描述

```properties
Keep-Alive: timeout
```

http请求是短连接，应用层级别上，每次请求都是独立的、短暂的。

但是，可能会面临对同一服务器的大量请求，为了避免TCP连接的频繁创建开销，可以延长TCP连接时长，以达到连接复用的目的。

对于http中的keep-alive，正确的功能描述应该是

> 当请求被正确响应之后，TCP连接空闲时间达到设定的timeout之后关闭。

- 优点：复用TCP连接，降低系统资源的频繁创建和回收开销
- 缺点：大量、长时间的无效资源占用，导致系统资源泄露，降低资源的利用率

### 启用办法

- ``http1.0``：

  在``http1.0``版本中，虽然支持``keep-alive``，但是需要手动开启。

  ```properties
  Connection: Keep-Alive
  ```

- ``http1.1``

  在``http1.1``开始，默认开启``keep-alive``，如果不需要，应当手动关闭。

  ```properties
  Connection: close
  ```

### 相关参数

- ``Content-Length``

复用连接，带来了好处，也会增加额外的管理开销。

不仅是底层TCP面临粘包拆包的问题，因为同属于同一应用的传输数据，在应用层也会面临拆包问题。

如何准确的确定一个请求是否全部应答完成，这就需要``Content-Length``进行判断和界定。

- ``Transfer-Encoding``

对于不能够确定长度的资源，也就是动态页面或者数据的情况，就需要通过``Transfer-Encoding``进行确认。

```properties
Transfer-Encoding: gzip
# 不仅是gzip，还分块传输，长度为0的chuncked标识结束
Transfer-Encoding: chuncked 
```

## TCP

对``TCP``而言，这个长连接并不一定是长久保持的，他只是在我们的需求范围内尽可能的不断开。

在业务场景下的主动断开就不必说了，``http``の``keep-alive``干的就是这个事情。

但是在需求范围内，操作系统也只能是``尽最大努力``，毕竟资源是有限的，``TCP``の``keep-alive``就是干的这个。

---

```properties
# 侦测周期
net.ipv4.tcp_keepalive_intvl = 15
# 侦测次数
net.ipv4.tcp_keepalive_probes = 5
# 空闲阈值
net.ipv4.tcp_keepalive_time = 1800
```

对于正在发送数据的``TCP``连接，毫无疑问是活跃的，但是对于非活跃的TCP连接，具体原因是不确定的

- 业务逻辑不闭环
  - 对端单方面断开，无完整挥手操作
- 底层环境有问题
  - 网络不可达
  - 对端程序崩溃

不论是何种问题，TCP的核心任务有两方面考量

1. 尽力完成需求
2. 如果不可能，需要保证系统稳定

关于上面三个参数，它的整体逻辑是这样的

1. 空闲检测：如果连接空闲时间超过设定keep-alive阈值，开始发送监测包
   - 有响应：连接正常
   - 无响应：进入周期检测
2. 周期检测：开始根据设定的检测周期，发送监测包
   - 有响应：恢复连接，重置控制参数
   - 无响应：已检测次数+1，对比检测阈值
     - 未达到阈值：指定周期后继续检测
     - 已达到阈值：关闭该连接，释放连接资源

## 结论

- ``http``：``keep-alive``用于对底层``TCP``连接的延迟关闭，避免连接重复创建、回收。
- ``TCP``：``keep-alive``用于对``TCP``连接的尽可能的维护检测，满足失效策略后回收无效占用资源。

具体区分，两者的本质完全不同，虽然都是空闲，都是``timeout``，但一个是杀，一个是救。