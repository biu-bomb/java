# 数据索引

如果每次都将数据全部加载到内存，就会造成内存的极大浪费。

使用索引直接锁定数据范围，针对性的加载数据，不仅能够降低内存消耗，还更加快速的定位数据。

## 结构划分

| 索引结构   | 优缺点分析                                                   |
| ---------- | ------------------------------------------------------------ |
| ``B-tree`` | 因为层级过深，导致查询效率不一，一般使用<br />数据存在于节点，无法支持范围查询和排序 |
| ``B+tree`` | 具体深度可由树的阶调节，深度可控<br />数据全部位于叶子节点，查询效率稳定，支持范围查询可排序 |
| ``hash``   | 直接锁定数据，效率最高<br />无法进行范围查询和排序等操作     |
| ``bitmap`` | 使用位图进行索引管理，极大降低索引数据体量<br />但是维护不易，目前就``Oracle``使用 |

## 映射划分

| 索引分类 | 映射办法                                             |
| -------- | ---------------------------------------------------- |
| 密集索引 | 类似``hash``，索引和数据一一对应                     |
| 稀疏索引 | 部分数据映射，划分数据区间，然后进入底层数据顺序查找 |

## 索引数据

| 索引分类   | 数据存储                                                     |
| ---------- | ------------------------------------------------------------ |
| 聚簇索引   | 节点路由，叶子存储数据                                       |
| 非聚簇索引 | 节点存储的是数据索引，具体数据还需要回表使用聚簇索引查询     |
| 覆盖索引   | 叶子节点存储的是部分数据字段，如果无需更多数据，可以直接返回，无需回表查询 |

## 联合索引

索引并非唯一索引，而是多个索引组合而成，索引拼接成``(A,B,C)``的形式。

![img](../.imgs/combine.png)

### 左匹配原则

因为联合索引都是拼接而成，都是顺序进行层级索引。

缺失前面的匹配索引，就完全利用不上联合索引；相反，即使后续索引数据缺乏，逐步匹配最左的索引也能逐步缩小数据范围。
