# Redis分布式锁

## 基础要求

| 要求      | 说明                                                         |
| --------- | ------------------------------------------------------------ |
| 安全属性  | 独享。同一时刻，同一把锁，只能被唯一客户端持有。             |
| 活性``A`` | 无死锁。即自动锁释放，当持有锁的客户端崩溃或者网络分裂，锁会自动释放，不会阻塞后续锁获取。 |
| 活性``B`` | 容错性。只要大部分``Redis``节点存活，客户端依旧可以获取和释放锁。 |

## 锁的主从不完备

因为``Redis``的主从同步是异步的，数据同步存在延迟；在数据同步间隔之间，``master``宕机，就会造成部分数据同步失败。

如果这部分数据中有锁的信息，当``slave``重新选举为``master``的时候，由于不存在锁的信息，完全无法保证锁的独享性。

## 单机锁

```shell
set lock_name lock_value nx px 30000
```

| field          | description                                                  |
| -------------- | ------------------------------------------------------------ |
| ``set``        | 使用数据进行锁的控制                                         |
| ``lock_name``  | 标识一把锁                                                   |
| ``lock_value`` | 类似``cas``思想，不仅需要标识一把锁，还需要声明什么条件才能修改这把锁<br />``lock_name``是共用的，唯一标识自身的唯有``lock_value``<br />因此，修改锁的时候不仅需要``lock_name``，还需要匹配``lock_value`` |
| ``nx``         | 不存在才设置，保证锁的排他性，防止覆盖                       |
| ``px``         | 为了保证客户端失效不会造成死锁，每一把锁都需要有过期时间     |
| ``30000``      | 过期时间不能太短<br />事务完成，客户端会自动释放锁。<br />但是事务进行过程中，不能够因为超时导致锁的释放，因此过期时间一定要大于事务执行时间。 |

# RedLock

> 分布式锁一般都需要集群中的半数以上节点支持，这是毋庸置疑的，但是相关细节需要探讨。

## 相关时间

| 相关时间     | 详细说明                                                     |
| ------------ | ------------------------------------------------------------ |
| 超时时间     | 请求应该设置超时时间，避免长时间阻塞等待。<br />这个时间应该是远小于事务执行时长的。 |
| 开始时刻     | 开始获取锁的时刻                                             |
| 获取锁时刻   | 锁的获取耗时，应当是从大多数节点都获取到锁的那一时刻。       |
| 获取锁耗时   | 获取锁时刻 - 开始时刻                                        |
| 有效时间     | 开始获取锁到锁释放的时间段                                   |
| 真实有效时间 | 有效时间 - 获取锁耗时<br />因为真正用在事务上的时间并不包含申请锁的消耗时间 |

## 安全性保障

| 保障措施   | 具体说明                                                     |
| ---------- | ------------------------------------------------------------ |
| 连接超时   | 设置超时时间，避免长时间等待                                 |
| 有效锁判断 | 虽然锁的有效使用时间从获取大多数节点锁开始<br />但是对于锁的过期时间，最早获取的节点早就开始计时<br />需要保证全部的锁的剩余时间是大于事务执行时间的。<br />否则视为锁获取失败，不能使用这把锁，会导致事务进行中锁过期。 |
| 无效锁解锁 | 有些锁虽然获取成功，但是不具备业务上的完整性，是无效锁。<br />这种情况下，直接广播解锁操作，不论节点是否加锁成功。 |
| 失败重试   | 不仅是释放，获取锁失败应当快速的进行解锁，也就是删除``lock_name``<br />因为具体判别使用的是``lock_value``，``nx``作用在``lock_name``之上<br />快速解锁，避免对其他客户端进行阻塞。<br />随机延迟：错开竞争时间，避免并发竞争导致频繁锁获取失败。 |

