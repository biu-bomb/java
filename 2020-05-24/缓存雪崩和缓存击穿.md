# 缓存作用

![在这里插入图片描述](d:/Users/admin/Videos/redis_cache.png)

随着``QPS``逐渐升高，对于数据库的直接查询的并发压力逐渐增大，已经超出数据库的承载能力或导致查询性能下降严重。

因此，基于内存或者更快的数据查询应运而生，作为缓冲桥梁搭建在查询请求和传统数据库之间，提供高``QPS``的查询能力。

# 缓存过期

真实业务都是基于传统数据库，它提供了更完备的持久化策略；因此，具体的数据总是以数据库数据为准。

为了避免数据库修改而缓存无感知导致的脏数据，缓存需要有和数据库进行数据同步的策略。

让新修改的数据得以更新到缓存中，杜绝脏数据导致的业务处理错误。

---

```flow
start=>start: query
redisExist=>condition: exist cache ?
getCache=>operation: get cache
saveCache=>operation: save cache
querySQL=>operation: query SQL
end=>end: return
start->redisExist(yes)->getCache->end
redisExist(no)->querySQL->saveCache->end
```



大多数场景下，都是设置过期时间，当缓存失效后，自动同步数据库数据，保证数据的准确性。

# 缓存穿透

按照缓存的流程，只要缓存中数据不存在，都会到数据库进行查询，并将结果缓存。

但是，如果数据库中也不存在数据，对于这种空数据集合的大批量查询，缓存形同虚设，全部查询请求都会直接透传给数据库。

并且由于缓存操作，比直接使用数据库带来更多的性能损耗。

---

核心在于判断一个数据的有效性，即数据存在与否。

| 解决办法   | 效果描述                                             | 影响                                           |
| ---------- | ---------------------------------------------------- | ---------------------------------------------- |
| 布隆过滤   | 将数据库数据``id``映射到布隆过滤器，先进行存在性检查 | 直接有效，新数据删除或插入需要维护             |
| 暂存默认值 | 将**不存在**映射特殊值，进行结果缓存                 | 不同的不存在数据，频繁触发缓存穿透，解决不全面 |

# 缓存击穿

当缓存过期，查询不到缓存数据的时候，需要从数据库中查询。

并发情况下，缓存数据过期，会导致大量的查询请求直接透传到数据库，这种情况就是**缓存击穿**。

---

本质原因在于数据同步的并发性，只需要单一线程同步即可，后续请求直接查询缓存即可。

| 解决办法 | 效果描述                               | 影响                                                       |
| -------- | -------------------------------------- | ---------------------------------------------------------- |
| 同步互斥 | 数据同步时候互斥，保证唯一线程同步     | 其余线程直接查询缓存，但是同步期间会被阻塞，冷数据过期清除 |
| 缓存维护 | 外部程序维护缓存修改，缓存数据永不过期 | 低阻塞，但是维护成本高，数据容量大且固定                   |

# 缓存雪崩

所谓**雪崩**，描述的是缓存大批量失效的情况，这个时候大量查询全部透传到数据库，缓存形同虚设。

关键点在于防止缓存数据的大批量失效，也就是错开缓存的失效、更新时间。

| 解决办法 | 效果描述                                   |
| -------- | ------------------------------------------ |
| 随机失效 | 设置随机过期时间，避免同一时刻大量缓存过期 |
| 缓存维护 | 缓存永不过期，外部程序维护数据同步         |

# 延时双删

## 数据更新

搭配缓存的时候，如果需要修改数据，同样也要更新缓存。单线程下没问题，但是多线程场景就会有一些奇妙的现象。

| 方案     | 操作                                           | 问题                                                         |
| -------- | ---------------------------------------------- | ------------------------------------------------------------ |
| 缓存更新 | 直接更新缓存，异步写入数据库                   | 如果读取初始版本的数据为多个线程，并都尝试修改缓存，会出现缓存覆盖 |
| 缓存删除 | 直接删除缓存，异步写入数据库，等待后续填充缓存 | 在删除缓存和写入数据库的这段时间，缓存失效且数据库数据非最新数据<br />后续缓存同步的必然是老版本数据，等数据插入数据库成功，就会出现脏数据 |

## 延时双删

综上所述，并发条件下的数据修改，如果遵循单一的修改原则，无法保证缓存数据的准确性。

- 延迟双删
  - 采取缓存删除的策略，修改数据
  - 延时一段时间，再次删除缓存

如果依托于缓存过期策略，度过频繁数据修改的阶段以后，数据也会得到一致性的更新。

但是在频繁修改阶段，脏数据就会长时间存在，除非单线程操作，才能避免并发脏数据的诞生。

采取延迟双删策略，将第二次的数据同步提前，在两次删除之间也可能出现脏数据，但是极大的缩小了脏数据的存活时间。