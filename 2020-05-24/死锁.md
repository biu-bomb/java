# 锁的核心特性

| 特性   | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| 排他性 | 独占性，保证资源独享                                         |
| 可获取 | 锁应该是可以进行获取的<br />不要求每次都能获取，也不要求立即获取，但具备获取的能力和可能 |
| 可释放 | 锁是应该可以释放的，但是只能被持有者释放，释放以后才会被其他线程抢占 |

# 死锁

从锁的角度并不好对**死锁**直接定义，但是针对**不获取锁就不能对资源进行操作**这一点，死锁可以解释为：**线程一直无法获取资源**。

由于无法获取资源，全部线程处于等待阻塞状态，程序逻辑无法进一步进行，这就是死锁，原因也是因为锁的管理出现问题。

# 原因

## 基础资质

| 特性   | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| 排他性 | 如果不具备排他性，操作相互覆盖，直接脏数据；排他性必须满足   |
| 可获取 | 如果不具备可获取，直接阻塞死锁；因此非自动闭环的锁需要匹配释放 |
| 可释放 | 如果不能释放，排他性满足情况下意味着不能获取                 |

## 并发管理

| 死锁条件 | 原因分析                                                     |
| -------- | ------------------------------------------------------------ |
| 未解锁   | 不解锁后续就不能获取，因此``unlock``需要确保``finally``，保证锁释放，否则会出现死锁 |
| 组合锁   | 如果使用的数多锁的组合，如果``A``和``B``部分锁都被不同线程持有，就会陷入相互等待的情况，陷入死锁 |
| 过渡礼让 | 如果检测到锁冲突，于是放弃争抢锁，一起抢，一起放，导致都无法获取锁，也算死锁。 |





