# 1. 存储介质

| 存储介质    | 读写级别  | 存储级别 |
| ----------- | --------- | -------- |
| 寄存器      | ``ns``    | ``b``    |
| ``CPU``缓存 | ``10ns``  | ``kb``   |
| 主存        | ``100ns`` | ``GB``   |
| 外部存储    | ``ms``    | ``TB``   |

## 1.1 cpu缓存

| 级别   | 说明                                     |
| ------ | ---------------------------------------- |
| ``L1`` | ``L1d``：数据缓存<br />``L1i``：指令缓存 |
| ``L2`` | ``CPU``内部缓存，不区分数据和指令        |
| ``L3`` | 多``CPU``共用                            |

# 2. 内存管理

<font color='red'>``MMU(内存管理单元)``：通过``CPU``将线性地址转换为物理地址。</font>

## 2.1 虚拟内存

- 物理内存

| 因素     | 影响                                       |
| -------- | ------------------------------------------ |
| 内存限制 | 物理内存大小存在固定限制，无法统一进行管理 |
| 地址问题 | 同类数据零散，管理复杂                     |
| 管理方式 | 不同``CPU``架构对于内存操作方式不同        |

- 虚拟内存

| 性质     | 优势                                                 |
| -------- | ---------------------------------------------------- |
| 地址连续 | 将离散物理地址映射为连续虚拟地址<br />方便管理和操作 |
| 管理屏蔽 | 抽象物理程序管理细节，提供顶层统一管理模式           |

- 映射方式

| 映射     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| 类型划分 | 将物理内存按照大小划分为页框、页<br />每块物理内存映射为一或多虚拟内存页 |
| 层级映射 | 高层级页表指向低层级页表，最低级页表记录物理地址             |

## 2.2 内存管理

| 管理方式       | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| 大页管理       | 内存访问速度远低于``CPU``，频繁查找效率不高<br />``TLB``作地址转换缓存，小页命中率低<br />适应大内存工作集，将页大小设置``MB``或者``TB``级别 |
| 特殊访问       | 硬件对不同范围物理地址访问有特殊限制<br />物理内存超过虚拟地址空间大小也需要特殊映射<br />``ZONE_DMA``：可直接``DMA``<br />``ZONE_NORMAL``：正常映射区域<br />``ZONE_HIGHMEM``：未映射内核空间的地址 |
| 节点划分       | 划分节点，每个节点构建独立内存管理子系统。<br />节点有自己的区域集、可用页、已用页和统计计数器 |
| 页缓存         | 外部存储介质``IO``操作消耗大，提供页缓存机制<br />文件读取：数据放入缓存页，避免后续磁盘访问<br />文件写入：优先写入页缓存，后续刷新脏页同步到磁盘 |
| 匿名内存       | 不受文件系统支持的内存<br />1. 程序堆栈，隐式创建<br />2. 显示``mmap``创建 |
| 内存回收       | 缓存页、匿名内存：刷新同步到磁盘<br />``DMA``缓冲区：存储内核数据结构，一般不回收，紧急情况下丢弃 |
| 内存整理       | 运行一段时间，会产生内存碎片<br />``kcompactd``进程完成内存压缩整理 |
| ``OOM Killer`` | 当内存耗尽，系统会尝试杀掉一些进程，以释放内存               |
| 内存分段       | ``CPU``寻址空间大于寄存器可用空间，无法直接寻址<br />将地址分段，对应寄存器空间，再检索页 |

# 3. 内存分配

| 分配场景       | 分配级别 | 分配方式                                                     |
| -------------- | -------- | ------------------------------------------------------------ |
| 大内存分配     | 页框     | 伙伴系统算法：将空闲页分为11个链表，$1..2^n..1024$。<br />需要``256``，直接获取空闲``256``大小页，不存在向上查找。<br />查``512``，有``256``空闲，分割``512``，空闲``256``分配，剩余``256``降级 |
| 小内存分配     | 页       | ``slab``                                                     |
| 非连续内存分配 |          | 避免外部内存碎片，但是内核页表较乱。                         |

# 4. 内存转换

|          | 实存                       | 虚存                                                         |
| -------- | -------------------------- | ------------------------------------------------------------ |
| 数据组成 | 已分配且已加载到主存的内存 | 进程可以访问的内存<br />1. 实存<br />2. 换出内存<br />3. 已分配未使用的内存 |

## 4.1 转换方式

| from | to   | description                                                  |
| ---- | ---- | ------------------------------------------------------------ |
| 实存 | 虚存 | 1. 加载：找到页面上驻留的物理地址，加载数据到主存<br />2. 分配：重新配置MMU，更新映射关系 |
| 虚存 | 实存 | 1. 刷出：将内存数据写入专用区域(交换空间或调页空间)<br />2. 回收：未修改的页面标记空闲(数据使用不频繁，先回收) |

