# 拥塞控制

>  <font color='red'>在某段时间，若**对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏**，这种情况就叫做**网络拥塞**。</font>

简而言之，就是大部分的请求得不到满足，导致传输链路上的有效传输降低，降低吞吐量。

因此，发生拥塞的时候的有效解决办法就是压制其他的数据传输，清理传输通道，优先满足重复请求。

| 拥塞情况 | 问题根源                                             |
| -------- | ---------------------------------------------------- |
| 数据丢失 | 数据丢失，大量重发请求占据通道                       |
| 热点资源 | 请求量大，占据传输通道，引起丢包，大量传输效率变坏。 |

## 基本参数

| param        | description                                                  |
| ------------ | ------------------------------------------------------------ |
| ``cwnd``     | 拥塞窗口                                                     |
| ``swnd``     | 发送窗口，大小为``cwnd``                                     |
| ``ssthresh`` | 慢开始门限值                                                 |
| ``RTT``      | 从发送端数据发出，到发送端接收到接收端发送的确认信号的时间。 |

> 后续数据大小以一个数据包为单位，默认一个数据包大小为``512byte``。

# 慢开启（``cwnd < ssthresh``）

| 阶段     | 操作                                 |
| -------- | ------------------------------------ |
| 初始化   | ``cwnd``初始化为1个数据包大小        |
| 数据确认 | 经过一个``RTT``，``cwnd = 2 * cwnd`` |

# 拥塞避免（``cwnd > ssthresh``）

| 拥塞场景 | 操作                                                         |
| -------- | ------------------------------------------------------------ |
| 无拥塞   | 每经过一个``RTT``，``cwnd = cwnd + 1``                       |
| 超时重传 | ``ssthresh = cwnd / 2; cwnd = 1``<br />门限调整为拥塞窗口的一般，并重新开始慢开启 |

# 快重传
> <font color='red'>如果``n``号数据没到，收到了``n``之后的数据包，则发送``n-1``数据包的确认报文。</font>

| 操作条件                 | 操作步骤                           |
| ------------------------ | ---------------------------------- |
| 连续三次接到重复重传信号 | 直接重传重复的数据包，不必等到超时 |

# 快恢复

| 操作条件                 | 操作步骤                                                     |
| ------------------------ | ------------------------------------------------------------ |
| 连续三次接到重复重传信号 | ``cwnd = ssthresh = ssthresh / 2``，并直接采用``cwnd += 1``算法 |





